#include "PS2Keyboard.h"

//#define SERIAL_DEBUG

#define NUMPAD  0x0100
#define NUMPAD2 0x0200

#define PS2_DATA_PIN  PIN_PC2   // 3
#define PS2_CLOCK_PIN PIN_PC3   // 2

#define MAC_DATA_PIN  PIN_PC0   // 5
#define MAC_CLOCK_PIN PIN_PC1   // 6

#undef  LED_BUILTIN
#define LED_BUILTIN PIN_PA5     // PIN_PA7 is default LED_BUILTIN; this is how you could redefine this if needed
								// my PCB has no LED so an unused pin will be switching between high and low and
								// that's okay.

#define NULL_TRANSITION 0x7b
#define CAPS_LOCK       0x73

PS2Keyboard keyboard;

//unsigned int scanCodesTable[256];
//unsigned int extScanCodesTable[256];

// had to hard-code these tables, instead of using initScancodes in keymap.ino, because the ATtiny806 doesn't have the 2k of memory
// needed to store these values. as a const (or using PROGMEM), megaTinyCore will put this variable into flash where we have plenty of
// space to store data. i've also changed them from unsigned int (4-byte) values to unsigned short (2-byte) values to further
// conserve program space.
//
// NOTE: with megaTinyCore you do NOT need to specify PROGMEM in order for these variables to be stored in
//       program space. megaTinyCore will do that automatically. 

const uint16_t scanCodesTable[256] = { 
  0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x0061, 0x0065, 0x007b,
  0x007b, 0x0075, 0x0071, 0x007b, 0x0075, 0x0019, 0x0025, 0x007b, 0x007b, 0x007b, 0x000d, 0x0003, 0x0001, 0x001b, 0x0027, 0x007b,
  0x007b, 0x0011, 0x000f, 0x0005, 0x001d, 0x002b, 0x0029, 0x007b, 0x007b, 0x0063, 0x0013, 0x0007, 0x0023, 0x001f, 0x002f, 0x007b,
  0x007b, 0x005b, 0x0017, 0x0009, 0x000b, 0x0021, 0x002d, 0x007b, 0x007b, 0x007b, 0x005d, 0x004d, 0x0041, 0x0035, 0x0039, 0x007b,
  0x007b, 0x0057, 0x0051, 0x0045, 0x003f, 0x003b, 0x0033, 0x007b, 0x007b, 0x005f, 0x0059, 0x004b, 0x0053, 0x0047, 0x0037, 0x007b,
  0x007b, 0x007b, 0x004f, 0x007b, 0x0043, 0x0031, 0x007b, 0x007b, 0x0073, 0x0071, 0x0049, 0x003d, 0x007b, 0x0055, 0x007b, 0x007b,
  0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x0067, 0x007b, 0x007b, 0x0127, 0x007b, 0x012d, 0x0133, 0x007b, 0x007b, 0x007b,
  0x0125, 0x0103, 0x0129, 0x012f, 0x0131, 0x0137, 0x007b, 0x010f, 0x007b, 0x020d, 0x012b, 0x011d, 0x0205, 0x0139, 0x007b, 0x007b,
  0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b,
  0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b,
  0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b,
  0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b,
  0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b,
  0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b,
  0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b,
  0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b,
};

const uint16_t extScanCodesTable[256] = { 
  0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b,
  0x007b, 0x0075, 0x007b, 0x007b, 0x0075, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x006f,
  0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x006f, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b,
  0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b,
  0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x021b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b,
  0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x0119, 0x006f, 0x006f, 0x007b, 0x007b, 0x007b,
  0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x010d, 0x007b, 0x007b, 0x007b, 0x007b,
  0x007b, 0x010f, 0x0111, 0x007b, 0x0105, 0x011b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b,
  0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x006f, 0x006f, 0x007b, 0x007b, 0x007b,
  0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b,
  0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b,
  0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b,
  0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b,
  0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b,
  0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b,
  0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b, 0x007b,
};

void setup() {
#ifdef SERIAL_DEBUG
  Serial.begin(9600);
#endif
  //initScancodes();

  keyboard.begin(PS2_DATA_PIN, PS2_CLOCK_PIN);

  pinMode(LED_BUILTIN, OUTPUT);
  pinMode(MAC_CLOCK_PIN, OUTPUT);
  pinMode(MAC_DATA_PIN, INPUT_PULLUP);
  
  waitForInitSignal();
  delayMicroseconds(180);
}

void waitForInitSignal() {
  unsigned long t = millis();
  boolean led = false;
  while (digitalRead(MAC_CLOCK_PIN) != LOW) {
    if (millis() - t > 100) {
      t = millis();
      led = !led;
      digitalWrite(LED_BUILTIN, led);
    }
  }
}

void loop() {
  switch (readCmd()) {
    case 0x10:
      inquiry();
      break;

    case 0x14: // instant
      sendKey(getKeyTransition());
      break;

    case 0x16: // model number
      sendByte(0x0b);
      break;

    case 0x36: // test
      sendByte(0x7d);
      break;
  }
}

// reads the command, operates the diagnostic LED and switches pin mode back to OUTPUT
byte readCmd() {
  digitalWrite(LED_BUILTIN, LOW);
  pinMode(MAC_DATA_PIN, INPUT_PULLUP);
  delayMicroseconds(20);
  
  while (digitalRead(MAC_DATA_PIN) != LOW);
  delayMicroseconds(400); // this is apparently required so we don't lose the first digit
  byte cmd = readByte();
  while (digitalRead(MAC_DATA_PIN) != HIGH);
  
  digitalWrite(LED_BUILTIN, HIGH);
  pinMode(MAC_DATA_PIN, OUTPUT);
  delayMicroseconds(20);
  return cmd;
}

void inquiry() {
  unsigned long start = millis();
  while ((millis() - start) < 250) {
    int key = getKeyTransition();
    if (key != NULL_TRANSITION) {
      sendKey(key);
      return;
    }
  }
  sendByte(NULL_TRANSITION);
}

void sendKey(unsigned int key) {
  if (key & NUMPAD) {
    sendByte(0x79); readCmd();
    sendByte(key);
  } else if (key & NUMPAD2) {
    sendByte(0x71); readCmd();
    sendByte(0x79); readCmd();
    sendByte(key);
  } else {
    sendByte(key);
  }
}

byte readByte() {
  byte b = 0;
  for (byte i = 0; i < 8; i++) {
    digitalWrite(MAC_CLOCK_PIN, LOW);
    delayMicroseconds(180);
    digitalWrite(MAC_CLOCK_PIN, HIGH);
    delayMicroseconds(80);
    b = (b << 1) | digitalRead(MAC_DATA_PIN);
    delayMicroseconds(140);
  }
#ifdef SERIAL_DEBUG
  Serial.print(b, HEX);
  Serial.print(" -> ");
#endif
  return b;
}

void sendByte(byte b) {
#ifdef SERIAL_DEBUG
  Serial.print(b, HEX);
  Serial.println();
#endif
  for (byte m = 128; m > 0; m >>= 1) {
    digitalWrite(MAC_DATA_PIN, !(b & m) ? LOW : HIGH);
    delayMicroseconds(40);
    digitalWrite(MAC_CLOCK_PIN, LOW);
    delayMicroseconds(120);
    digitalWrite(MAC_CLOCK_PIN, HIGH);
    delayMicroseconds(170);
  }
  digitalWrite(MAC_DATA_PIN, HIGH);
}

unsigned int getKeyTransition() {
  byte c = keyboard.getScanCode();
  if (c == 0) {
    return NULL_TRANSITION;
  } else if (c == 0xf0) {
    return translate(waitForScanCode(), false, true);
  } else if (c == 0xe0) {
    return getExtendedTransition();
  } else {
    return translate(c, false, false);
  }
}

unsigned int getExtendedTransition() {
  byte c = waitForScanCode();
  if (c == 0xf0) {
    return translate(waitForScanCode(), true, true);
  } else {
    return translate(c, true, false);
  }
}

unsigned int translate(byte scanCode, boolean extended, boolean released) {
  unsigned int translated = extended ? extScanCodesTable[scanCode] : scanCodesTable[scanCode];
  if (translated == NULL_TRANSITION) {
    return NULL_TRANSITION;
  } else if (released) {
    if (translated == CAPS_LOCK) {
      return handleCapsLockRelease();
    } else {
      return translated | 0x80;
    }
  } else {
    return translated;
  }
}

boolean capsLockPressed = false;

unsigned int handleCapsLockRelease() {
  if (capsLockPressed) {
    capsLockPressed = false;
    return CAPS_LOCK | 0x80;
  } else {
    capsLockPressed = true;
    return NULL_TRANSITION;
  }
}

byte waitForScanCode() {
  while (true) {
    byte s = keyboard.getScanCode();
    if (s) {
      return s;
    }
  }
}
